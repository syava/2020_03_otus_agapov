Анализ работы разных GC на самом простом скрипте.
OutOfMemory.java

Анализировал по логам (xmx 16mb):
1) G1
равномерная пауза во время работы gc
2) ParallelGC
в начале, gc был быстрым, т.к. чистилось молодое поколение. Но когда появилась необходимость чистить старое, то задержки стали сразу больше
3) ZGC - проверял на java 14
был прогрем на старте приложения. Похоже, что он выделил сразу память, т.к. сразу было 10mb. Дальше пытался чистить, но упал быстрее, чем остальные. 
4) SerialGC
похоже на работы ParallelGC, но было больше чисток старого покаления. т.е. общее время пауз, было намного больше

Анализировал по логам (xmx 8192mb):
1) G1
равномерная пауза во время работы gc. При этом, когда потребовалось почистить много данных, потребовался долгий GC
2) ParallelGC
количество задержек меньше, но они все дольше

Для моего теста, разницы нет, какoй gc будет. Тут зависит от того, что хочется получить видимо.
Если будет какой нибудь веб сервер, который должен работать обрабатывать запросы почаще, то G1 будет лучше. т.к. клиенты будут получать быстрее ответы.
А если мы выставим Parallel или Serial, то будет долгое ожидание. 

По поводу скорости работы:
на моем примере с xmx 8Gb, быстрее всех работал SerialGC. Хотя это странно
Добавив логирование работы цикла, получилось, что SerialGC отрабатывал от 19 до 23 секунд. При этом G1 работал от 23 до 29 секунд.

Добавил отчистку массива и запустил на более длительное время. Получилось, что G1 в среднем отрабатывал быстрее, чем Serial и Parallel
Результаты получились такие:
G1 - 1:31 
Parallel 1:36
Serial 1:41